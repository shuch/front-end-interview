## `js`连等赋值

先看一道题
```js
var a = {n:1};
var b = a;
a.x = a = {n:2};

console.log(a.x);// undefined
console.log(b.x);// {n:2}
```

运算顺序
* `.`成员访问运算符优先级是19，`=`赋值运算符优先级是10
* `=`是右关联的，即相同优先级从右到左执行。
* `=`返回值是右边的值

运算过程
* 第一行为`{a:1}`分配堆内存，`a`指向这个地址，假设是`0x1`。
* 第二行`a`的内存地址赋给`b`，即指向同一个内存地址`0x1`。
* 第三行
`.`优先级最高，先解析`a.x`，属性不存在，会创建`x`，此时`0x1`内容是
```js
// heap 0x1
{
  n: 1,
  x: undefined,
}
```

再执行赋值运算符，`a = {n:2}`，为`{n:2}`分配一块堆内存`0x2`，同时`a`指向变为`0x2`，
```js
// heap 0x2
{
  n: 2
}
```

右边赋值结果返回值为`{n:2}`

此时执行`a.x = {n:2}`，由于在执行赋值运算之前，已经访问过`a`, 这里直接取旧的值，即`0x1`，赋值后`0x1`内容变为
```js
// heap 0x1
{
  n: 1,
  x: {n:2},
}
```

最后的状态是`a`指向变为`0x2`，`b`指向没有变还是`0x2`

## 参考
* [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
* [一道赋值面试题引发的思考](https://juejin.im/post/5b605473e51d45191a0d81d8)

